"""
CIF Writer
==========

"""

from __future__ import annotations

import typing
import stk
import numpy as np


class CifWriter:
    """
    A writer class for ``.cif`` files in P1 symmetry only.

    """

    def _write_content(
        self,
        molecule: stk.Molecule,
        atom_ids: typing.Optional[stk.OneOrMany[int]],
        periodic_info: typing.Optional[stk.PeriodicInfo],
    ) -> list[str]:

        if atom_ids is None:
            atom_ids = range(molecule.get_num_atoms())
        elif isinstance(atom_ids, int):
            atom_ids = (atom_ids,)

        a = round(periodic_info.get_a(), 3)
        b = round(periodic_info.get_b(), 3)
        c = round(periodic_info.get_c(), 3)
        alpha = round(periodic_info.get_alpha(), 3)
        beta = round(periodic_info.get_beta(), 3)
        gamma = round(periodic_info.get_gamma(), 3)
        inv_matrix = np.linalg.inv(periodic_info.get_cell_matrix())

        top_string = (
            "data_cif\n\n"
            "_audit_creation_method             'generated by stk'\n\n"
            "_symmetry_space_group_name_H-M     'P 1'\n"
            "_symmetry_Int_Tables_number        1\n"
            "_symmetry_cell_setting             triclinic\n\n"
            f"_cell_length_a                    {a}\n"
            f"_cell_length_b                    {b}\n"
            f"_cell_length_c                    {c}\n"
            f"_cell_angle_alpha                 {alpha}\n"
            f"_cell_angle_beta                  {beta}\n"
            f"_cell_angle_gamma                 {gamma}\n\n"
            "loop_\n"
            "_atom_site_label\n"
            "_atom_site_fract_x\n"
            "_atom_site_fract_y\n"
            "_atom_site_fract_z\n"
            "_atom_site_occupancy\n"
        )
        content = [top_string]

        atom_counts: dict[str, int] = {}
        coords = molecule.get_position_matrix()
        frac_coords = np.dot(coords, inv_matrix)
        for atom_id in atom_ids:
            (atom,) = molecule.get_atoms(atom_ids=atom_id)
            x, y, z = (i for i in frac_coords[atom_id])
            element = atom.__class__.__name__
            atom_counts[element] = atom_counts.get(element, 0) + 1
            name = f"{element}{atom_counts[element]}"
            occu = 1.0
            content.append(f"{name} {x} {y} {z} {occu}\n")

        return content

    def to_string(
        self,
        molecule: stk.Molecule,
        atom_ids: typing.Optional[stk.OneOrMany[int]] = None,
        periodic_info: typing.Optional[stk.PeriodicInfo] = None,
    ) -> str:
        """
        Get a ``.cif`` file format string of `molecule` in P1.

        Parameters:

            molecule:
                Molecule to write to ``.cif`` format.

            atom_ids:
                The atom ids of atoms to write. Can be a single
                :class:`int`, if a single atom is to be used, or
                ``None``, if all atoms are to be used.

            periodic_info:
                Information about the periodic cell.

        Returns:

            A string holding the content of a ``.cif`` file.

        """

        content = self._write_content(
            molecule=molecule,
            atom_ids=atom_ids,
            periodic_info=periodic_info,
        )

        return "".join(content)

    def write(
        self,
        molecule: stk.Molecule,
        path: str,
        atom_ids: typing.Optional[stk.OneOrMany[int]] = None,
        periodic_info: typing.Optional[stk.PeriodicInfo] = None,
    ) -> None:
        """
        Write `molecule` to ``.cif`` file format in P1.

        Parameters:

            molecule:
                Molecule to write to ``.cif`` format.

            path:
                The full path to the file being written.

            atom_ids:
                The atom ids of atoms to write. Can be a single
                :class:`int`, if a single atom is to be used, or
                ``None``, if all atoms are to be used.

            periodic_info:
                Information about the periodic cell.

        """

        content = self._write_content(
            molecule=molecule,
            atom_ids=atom_ids,
            periodic_info=periodic_info,
        )

        with open(path, "w") as f:
            f.write("".join(content))
